<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¢å¼ºç‰ˆWebDAVè§†é¢‘æ’­æ”¾å™¨</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            margin: 0;
            background: #1a1a1a;
            color: #ffffff;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            text-align: center;
            margin-bottom: 20px;
            background: #2d2d2d;
            padding: 20px;
            border-radius: 8px;
        }
        .config-section {
            background: #2d2d2d;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .form-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #ccc;
        }
        .form-group input {
            width: 100%;
            padding: 10px;
            background: #1a1a1a;
            border: 1px solid #555;
            color: white;
            border-radius: 4px;
        }
        button {
            padding: 10px 20px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover:not(:disabled) {
            background: #0056b3;
        }
        button:disabled {
            background: #555;
            cursor: not-allowed;
        }
        .main-layout {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }
        .video-section {
            background: #2d2d2d;
            border-radius: 8px;
            overflow: hidden;
        }
        .video-container {
            position: relative;
            background: #000;
        }
        video {
            width: 100%;
            height: auto;
            display: block;
        }
        .video-controls {
            padding: 15px;
            background: #2d2d2d;
        }
        .progress-container {
            position: relative;
            height: 8px;
            background: #555;
            border-radius: 4px;
            margin: 10px 0;
            cursor: pointer;
            overflow: hidden;
        }
        .progress-buffer {
            position: absolute;
            height: 100%;
            background: #777;
            border-radius: 4px;
            transition: width 0.1s;
        }
        .progress-segments {
            position: absolute;
            height: 100%;
            width: 100%;
            top: 0;
            left: 0;
        }
        .progress-segment {
            position: absolute;
            height: 100%;
            background: #28a745;
            opacity: 0.6;
            border-radius: 1px;
        }
        .progress-downloading {
            position: absolute;
            height: 100%;
            background: #ffc107;
            opacity: 0.8;
            border-radius: 1px;
            animation: pulse 1s infinite;
        }
        .progress-bar {
            position: absolute;
            height: 100%;
            background: #007bff;
            border-radius: 4px;
            transition: width 0.1s;
            z-index: 10;
        }
        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 0.4; }
        }
        .time-display {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #ccc;
            margin-top: 5px;
        }
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .panel {
            background: #2d2d2d;
            border-radius: 8px;
            overflow: hidden;
        }
        .panel-header {
            background: #3d3d3d;
            padding: 10px 15px;
            font-weight: 500;
            border-bottom: 1px solid #555;
        }
        .panel-content {
            padding: 15px;
        }
        .file-list {
            max-height: 300px;
            overflow-y: auto;
        }
        .file-item {
            padding: 8px 12px;
            margin-bottom: 4px;
            background: #1a1a1a;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .file-item:hover {
            background: #404040;
        }
        .file-item.active {
            background: #007bff;
        }
        .file-item.video {
            border-left: 3px solid #28a745;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        .stat-item {
            background: #1a1a1a;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
        }
        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #007bff;
        }
        .stat-label {
            font-size: 12px;
            color: #ccc;
            margin-top: 4px;
        }
        .log-container {
            background: #1a1a1a;
            height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 10px;
            border-radius: 4px;
        }
        .log-entry {
            margin-bottom: 4px;
            word-wrap: break-word;
        }
        .log-entry.info { color: #17a2b8; }
        .log-entry.success { color: #28a745; }
        .log-entry.warning { color: #ffc107; }
        .log-entry.error { color: #dc3545; }
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: #3d3d3d;
            border-radius: 0 0 8px 8px;
            font-size: 12px;
        }
        .loading {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #555;
            border-top: 2px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .hidden { display: none !important; }
        
        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 1024px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
            .stats-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¬ å¢å¼ºç‰ˆWebDAVè§†é¢‘æ’­æ”¾å™¨</h1>
            <p>æ”¯æŒRangeè¯·æ±‚ã€æ™ºèƒ½ç¼“å­˜ã€å®æ—¶ç›‘æ§</p>
        </div>

        <div class="config-section">
            <div class="form-row">
                <div class="form-group">
                    <label>æœåŠ¡å™¨åœ°å€:</label>
                    <input type="text" id="serverUrl" value="http://localhost:8090" />
                </div>
                <div class="form-group">
                    <label>ç”¨æˆ·å:</label>
                    <input type="text" id="username" value="18867123055" />
                </div>
                <div class="form-group">
                    <label>å¯†ç :</label>
                    <input type="password" id="password" value="1x1v8bj1000dbj9o9s1ay9setkp4d8zg" />
                </div>
                <div class="form-group">
                    <label>è·¯å¾„:</label>
                    <input type="text" id="basePath" value="/å°é²¸é±¼" />
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label>é¢„åŠ è½½ç­–ç•¥:</label>
                    <select id="preloadMode" style="width: 100%; padding: 10px; background: #1a1a1a; border: 1px solid #555; color: white; border-radius: 4px;">
                        <option value="auto">è‡ªåŠ¨é¢„ç¼“å†² (æ¨è)</option>
                        <option value="metadata">ä»…å…ƒæ•°æ®</option>
                        <option value="none">ä¸é¢„åŠ è½½</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>ç¼“å†²å¤§å°:</label>
                    <select id="bufferSize" style="width: 100%; padding: 10px; background: #1a1a1a; border: 1px solid #555; color: white; border-radius: 4px;">
                        <option value="5">5MB (ç§»åŠ¨ç½‘ç»œ)</option>
                        <option value="10" selected>10MB (æ ‡å‡†)</option>
                        <option value="20">20MB (é«˜é€Ÿç½‘ç»œ)</option>
                        <option value="50">50MB (æœ¬åœ°ç½‘ç»œ)</option>
                    </select>
                </div>
            </div>
            <button id="connectBtn">è¿æ¥æœåŠ¡å™¨</button>
            <button id="refreshBtn" class="hidden">åˆ·æ–°æ–‡ä»¶</button>
            <button id="statsBtn" class="hidden">æŸ¥çœ‹ç»Ÿè®¡</button>
        </div>

        <div class="main-layout">
            <div class="video-section">
                <div class="video-container">
                    <video id="videoPlayer" preload="auto" controls>
                        æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè§†é¢‘æ’­æ”¾
                    </video>
                </div>
                <div class="video-controls">
                    <div class="progress-container" id="progressContainer">
                        <div class="progress-buffer" id="progressBuffer"></div>
                        <div class="progress-segments" id="progressSegments"></div>
                        <div class="progress-bar" id="progressBar"></div>
                    </div>
                    <div class="time-display">
                        <span id="currentTime">00:00</span>
                        <span>ç¼“å†²: <span id="bufferStatus">0%</span></span>
                        <span>ç½‘é€Ÿ: <span id="networkSpeed">0 KB/s</span></span>
                        <span id="duration">00:00</span>
                    </div>
                </div>
                <div class="status-bar">
                    <span id="videoStatus">ç­‰å¾…é€‰æ‹©è§†é¢‘...</span>
                    <span id="downloadSpeed">0 KB/s</span>
                </div>
            </div>

            <div class="sidebar">
                <div class="panel">
                    <div class="panel-header">ğŸ“Š å®æ—¶ç»Ÿè®¡</div>
                    <div class="panel-content">
                        <div class="stats-grid">
                            <div class="stat-item">
                                <div class="stat-value" id="cacheHits">0</div>
                                <div class="stat-label">ç¼“å­˜å‘½ä¸­</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="cacheMisses">0</div>
                                <div class="stat-label">ç¼“å­˜æœªå‘½ä¸­</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="hitRate">0%</div>
                                <div class="stat-label">å‘½ä¸­ç‡</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="cacheSize">0 MB</div>
                                <div class="stat-label">ç¼“å­˜å¤§å°</div>
                            </div>
                        </div>
                        <button onclick="updateStats()">åˆ·æ–°ç»Ÿè®¡</button>
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-header">ğŸ“ è§†é¢‘æ–‡ä»¶</div>
                    <div class="panel-content">
                        <div id="fileList" class="file-list">
                            <div style="text-align: center; color: #666; padding: 20px;">
                                è¯·å…ˆè¿æ¥æœåŠ¡å™¨
                            </div>
                        </div>
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-header">ğŸ“ å®æ—¶æ—¥å¿—</div>
                    <div class="panel-content">
                        <div id="logContainer" class="log-container"></div>
                        <button onclick="clearLogs()" style="margin-top: 10px;">æ¸…ç©ºæ—¥å¿—</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let isConnected = false;
        let authHeader = '';
        let serverUrl = '';
        let basePath = '';
        let currentVideo = null;
        let statsInterval = null;
        let preloadInterval = null;
        let bufferConfig = { mode: 'auto', size: 10 }; // MB

        // DOMå…ƒç´ 
        const elements = {
            serverUrl: document.getElementById('serverUrl'),
            username: document.getElementById('username'),
            password: document.getElementById('password'),
            basePath: document.getElementById('basePath'),
            preloadMode: document.getElementById('preloadMode'),
            bufferSize: document.getElementById('bufferSize'),
            connectBtn: document.getElementById('connectBtn'),
            refreshBtn: document.getElementById('refreshBtn'),
            statsBtn: document.getElementById('statsBtn'),
            videoPlayer: document.getElementById('videoPlayer'),
            progressContainer: document.getElementById('progressContainer'),
            progressBuffer: document.getElementById('progressBuffer'),
            progressSegments: document.getElementById('progressSegments'),
            progressBar: document.getElementById('progressBar'),
            bufferStatus: document.getElementById('bufferStatus'),
            networkSpeed: document.getElementById('networkSpeed'),
            currentTime: document.getElementById('currentTime'),
            duration: document.getElementById('duration'),
            videoStatus: document.getElementById('videoStatus'),
            downloadSpeed: document.getElementById('downloadSpeed'),
            fileList: document.getElementById('fileList'),
            logContainer: document.getElementById('logContainer'),
            cacheHits: document.getElementById('cacheHits'),
            cacheMisses: document.getElementById('cacheMisses'),
            hitRate: document.getElementById('hitRate'),
            cacheSize: document.getElementById('cacheSize')
        };

        // æ—¥å¿—è®°å½•
        function addLog(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const div = document.createElement('div');
            div.className = `log-entry ${type}`;
            div.textContent = `[${timestamp}] ${message}`;
            
            elements.logContainer.appendChild(div);
            elements.logContainer.scrollTop = elements.logContainer.scrollHeight;
            
            // é™åˆ¶æ—¥å¿—æ¡æ•°
            while (elements.logContainer.children.length > 100) {
                elements.logContainer.removeChild(elements.logContainer.firstChild);
            }
            
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        // æ¸…ç©ºæ—¥å¿—
        function clearLogs() {
            elements.logContainer.innerHTML = '';
            addLog('æ—¥å¿—å·²æ¸…ç©º', 'info');
        }

        // è¿æ¥æœåŠ¡å™¨
        async function connectToServer() {
            try {
                elements.connectBtn.disabled = true;
                addLog('æ­£åœ¨è¿æ¥æœåŠ¡å™¨...', 'info');

                serverUrl = elements.serverUrl.value.trim();
                const username = elements.username.value.trim();
                const password = elements.password.value;
                basePath = elements.basePath.value.trim() || '/';

                if (!serverUrl || !username) {
                    throw new Error('è¯·å¡«å†™æœåŠ¡å™¨åœ°å€å’Œç”¨æˆ·å');
                }

                authHeader = 'Basic ' + btoa(username + ':' + password);

                // æµ‹è¯•è¿æ¥
                const response = await fetch(serverUrl + basePath, {
                    method: 'PROPFIND',
                    headers: {
                        'Authorization': authHeader,
                        'Content-Type': 'application/xml',
                        'Depth': '1'
                    },
                    body: `<?xml version="1.0" encoding="utf-8"?>
                        <d:propfind xmlns:d="DAV:">
                            <d:prop>
                                <d:displayname/>
                                <d:getcontentlength/>
                                <d:getcontenttype/>
                                <d:resourcetype/>
                            </d:prop>
                        </d:propfind>`
                });

                if (!response.ok) {
                    throw new Error(`è¿æ¥å¤±è´¥: ${response.status} ${response.statusText}`);
                }

                const xmlText = await response.text();
                const files = parseWebDAVResponse(xmlText);

                isConnected = true;
                elements.refreshBtn.classList.remove('hidden');
                elements.statsBtn.classList.remove('hidden');

                addLog(`è¿æ¥æˆåŠŸï¼æ‰¾åˆ° ${files.length} ä¸ªé¡¹ç›®`, 'success');
                displayFiles(files);
                
                // å¼€å§‹å®šæœŸæ›´æ–°ç»Ÿè®¡
                startStatsUpdate();

            } catch (error) {
                addLog(`è¿æ¥å¤±è´¥: ${error.message}`, 'error');
            } finally {
                elements.connectBtn.disabled = false;
            }
        }

        // è§£æWebDAVå“åº”
        function parseWebDAVResponse(xmlText) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
            const responses = xmlDoc.querySelectorAll('response');
            const files = [];

            responses.forEach(response => {
                const href = response.querySelector('href')?.textContent;
                if (!href) return;

                const props = response.querySelector('prop');
                if (!props) return;

                const displayname = props.querySelector('displayname')?.textContent || '';
                const contentLength = props.querySelector('getcontentlength')?.textContent || '0';
                const contentType = props.querySelector('getcontenttype')?.textContent || '';
                const resourceType = props.querySelector('resourcetype');
                
                const isCollection = resourceType?.querySelector('collection') !== null;
                const isVideo = contentType.startsWith('video/') || 
                               displayname.match(/\.(mp4|avi|mov|mkv|webm|m4v)$/i);

                if (href === serverUrl + basePath || href.endsWith(basePath + '/')) {
                    return;
                }

                files.push({
                    name: displayname || decodeURIComponent(href.split('/').pop()),
                    href: href,
                    size: parseInt(contentLength) || 0,
                    type: contentType,
                    isDirectory: isCollection,
                    isVideo: isVideo && !isCollection
                });
            });

            return files.sort((a, b) => {
                if (a.isDirectory !== b.isDirectory) {
                    return a.isDirectory ? -1 : 1;
                }
                return a.name.localeCompare(b.name);
            });
        }

        // æ˜¾ç¤ºæ–‡ä»¶åˆ—è¡¨
        function displayFiles(files) {
            elements.fileList.innerHTML = '';

            const videoFiles = files.filter(f => f.isVideo);
            if (videoFiles.length === 0) {
                elements.fileList.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">æœªæ‰¾åˆ°è§†é¢‘æ–‡ä»¶</div>';
                return;
            }

            videoFiles.forEach(file => {
                const div = document.createElement('div');
                div.className = 'file-item video';
                div.innerHTML = `
                    <span>ğŸ¬</span>
                    <div style="flex: 1;">
                        <div>${file.name}</div>
                        <div style="font-size: 11px; color: #666;">${formatFileSize(file.size)}</div>
                    </div>
                `;
                
                div.onclick = () => playVideo(file);
                elements.fileList.appendChild(div);
            });
        }

        // æ›´æ–°ç¼“å†²é…ç½®
        function updateBufferConfig() {
            bufferConfig.mode = elements.preloadMode.value;
            bufferConfig.size = parseInt(elements.bufferSize.value);
            
            // æ›´æ–°è§†é¢‘preloadå±æ€§
            elements.videoPlayer.preload = bufferConfig.mode;
            
            addLog(`ç¼“å†²é…ç½®å·²æ›´æ–°: ${bufferConfig.mode}, ${bufferConfig.size}MB`, 'info');
        }

        // æ™ºèƒ½é¢„ç¼“å†²çŠ¶æ€
        let prebufferState = {
            isActive: false,
            lastPosition: 0,
            speed: 0, // bytes per second
            queue: [],
            downloading: new Set(),
            cachedSegments: new Map(), // ç¼“å­˜çš„åˆ†æ®µä¿¡æ¯
            downloadStats: {
                totalBytes: 0,
                totalTime: 0,
                recentSpeeds: []
            }
        };

        // æ›´æ–°ç¼“å†²æ®µå¯è§†åŒ–
        function updateBufferVisualization() {
            if (!currentVideo) return;
            
            const segmentsContainer = elements.progressSegments;
            segmentsContainer.innerHTML = '';
            
            // æ˜¾ç¤ºå·²ç¼“å­˜çš„åˆ†æ®µ
            for (const [key, segment] of prebufferState.cachedSegments) {
                const startPercent = (segment.start / currentVideo.size) * 100;
                const endPercent = (segment.end / currentVideo.size) * 100;
                const width = Math.max(0.1, endPercent - startPercent); // æœ€å°0.1%å®½åº¦
                
                const segmentDiv = document.createElement('div');
                segmentDiv.className = 'progress-segment';
                segmentDiv.style.left = startPercent + '%';
                segmentDiv.style.width = width + '%';
                segmentDiv.title = `ç¼“å­˜åˆ†æ®µ: ${Math.floor(segment.start / 1024 / 1024)}MB - ${Math.floor(segment.end / 1024 / 1024)}MB`;
                
                segmentsContainer.appendChild(segmentDiv);
            }
            
            // æ˜¾ç¤ºæ­£åœ¨ä¸‹è½½çš„åˆ†æ®µ
            for (const key of prebufferState.downloading) {
                const [start, end] = key.split('-').map(Number);
                const startPercent = (start / currentVideo.size) * 100;
                const endPercent = (end / currentVideo.size) * 100;
                const width = Math.max(0.1, endPercent - startPercent);
                
                const downloadingDiv = document.createElement('div');
                downloadingDiv.className = 'progress-downloading';
                downloadingDiv.style.left = startPercent + '%';
                downloadingDiv.style.width = width + '%';
                downloadingDiv.title = `ä¸‹è½½ä¸­: ${Math.floor(start / 1024 / 1024)}MB - ${Math.floor(end / 1024 / 1024)}MB`;
                
                segmentsContainer.appendChild(downloadingDiv);
            }
        }

        // æ›´æ–°ç½‘é€Ÿæ˜¾ç¤º
        function updateNetworkSpeed() {
            const stats = prebufferState.downloadStats;
            if (stats.recentSpeeds.length > 0) {
                const avgSpeed = stats.recentSpeeds.reduce((a, b) => a + b, 0) / stats.recentSpeeds.length;
                const speedText = avgSpeed > 1024 ? 
                    `${(avgSpeed / 1024).toFixed(1)} MB/s` : 
                    `${avgSpeed.toFixed(0)} KB/s`;
                
                elements.networkSpeed.textContent = speedText;
                elements.downloadSpeed.textContent = speedText;
            }
        }

        // æ›´æ–°ç¼“å†²çŠ¶æ€
        function updateBufferStatus() {
            if (!currentVideo) return;
            
            const video = elements.videoPlayer;
            const buffered = video.buffered;
            
            if (buffered.length > 0 && video.duration) {
                let bufferedDuration = 0;
                for (let i = 0; i < buffered.length; i++) {
                    bufferedDuration += buffered.end(i) - buffered.start(i);
                }
                
                const bufferPercent = (bufferedDuration / video.duration * 100).toFixed(1);
                elements.bufferStatus.textContent = bufferPercent + '%';
                
                // æ›´æ–°æµè§ˆå™¨åŸç”Ÿç¼“å†²æ¡
                if (buffered.length > 0) {
                    const bufferProgress = (buffered.end(buffered.length - 1) / video.duration) * 100;
                    elements.progressBuffer.style.width = bufferProgress + '%';
                }
            }
        }

        // è®¡ç®—æ’­æ”¾é€Ÿåº¦
        function calculatePlaybackSpeed() {
            const video = elements.videoPlayer;
            if (!video.duration || !video.currentTime) return 0;
            
            const now = Date.now();
            const currentPos = video.currentTime;
            const timeDelta = (now - (prebufferState.lastCheck || now)) / 1000;
            const posDelta = currentPos - prebufferState.lastPosition;
            
            if (timeDelta > 0) {
                const bytesPerSecond = (posDelta / video.duration) * currentVideo.size / timeDelta;
                prebufferState.speed = Math.max(0, bytesPerSecond);
            }
            
            prebufferState.lastPosition = currentPos;
            prebufferState.lastCheck = now;
            
            return prebufferState.speed;
        }

        // æ™ºèƒ½é¢„ç¼“å†²å‡½æ•°
        async function backgroundPrebuffer(videoUrl, currentTime, duration) {
            if (bufferConfig.mode !== 'auto' || !currentVideo || prebufferState.isActive) return;
            
            prebufferState.isActive = true;
            
            try {
                const video = elements.videoPlayer;
                const isPaused = video.paused;
                const playbackSpeed = calculatePlaybackSpeed();
                
                // è®¡ç®—å½“å‰æ’­æ”¾ä½ç½®çš„å­—èŠ‚ä½ç½®
                const currentByte = Math.floor((currentTime / duration) * currentVideo.size);
                const segmentSize = 2 * 1024 * 1024; // 2MB
                
                // ç¡®å®šé¢„ç¼“å†²ç­–ç•¥
                let prebufferBytes = bufferConfig.size * 1024 * 1024; // åŸºç¡€ç¼“å†²å¤§å°
                
                if (isPaused) {
                    // æš‚åœæ—¶ï¼Œæ›´ç§¯æåœ°é¢„ç¼“å†²
                    prebufferBytes = Math.min(prebufferBytes * 2, 50 * 1024 * 1024); // æœ€å¤š50MB
                    addLog('è§†é¢‘æš‚åœï¼Œå¯åŠ¨ç§¯æé¢„ç¼“å†²', 'info');
                } else if (playbackSpeed > 0) {
                    // æ ¹æ®æ’­æ”¾é€Ÿåº¦è°ƒæ•´é¢„ç¼“å†²å¤§å°
                    const predictedNeedBytes = playbackSpeed * 30; // é¢„æµ‹30ç§’éœ€è¦çš„æ•°æ®
                    prebufferBytes = Math.max(prebufferBytes, predictedNeedBytes);
                }
                
                // åˆ†æ®µä¸‹è½½
                const segments = [];
                let nextByte = currentByte;
                const maxByte = Math.min(currentByte + prebufferBytes, currentVideo.size - 1);
                
                while (nextByte < maxByte) {
                    const segmentEnd = Math.min(nextByte + segmentSize - 1, maxByte);
                    const segmentKey = `${nextByte}-${segmentEnd}`;
                    
                    // é¿å…é‡å¤ä¸‹è½½
                    if (!prebufferState.downloading.has(segmentKey)) {
                        segments.push({ start: nextByte, end: segmentEnd, key: segmentKey });
                        prebufferState.downloading.add(segmentKey);
                    }
                    
                    nextByte = segmentEnd + 1;
                }
                
                if (segments.length === 0) {
                    prebufferState.isActive = false;
                    return;
                }
                
                addLog(`å¯åŠ¨é¢„ç¼“å†²: ${segments.length} ä¸ªåˆ†æ®µï¼Œæ€»è®¡ ${Math.floor(prebufferBytes / 1024 / 1024)}MB`, 'info');
                
                // å¹¶å‘ä¸‹è½½å¤šä¸ªåˆ†æ®µï¼ˆæœ€å¤š3ä¸ªå¹¶å‘ï¼‰
                const concurrency = Math.min(3, segments.length);
                const promises = [];
                
                for (let i = 0; i < concurrency; i++) {
                    promises.push(downloadSegmentQueue(videoUrl, segments, i));
                }
                
                await Promise.all(promises);
                
            } catch (error) {
                addLog(`é¢„ç¼“å†²å‡ºé”™: ${error.message}`, 'warning');
            } finally {
                prebufferState.isActive = false;
            }
        }

        // åˆ†æ®µé˜Ÿåˆ—ä¸‹è½½å™¨
        async function downloadSegmentQueue(videoUrl, segments, workerId) {
            while (segments.length > 0) {
                const segment = segments.shift();
                if (!segment) break;
                
                try {
                    const startTime = Date.now();
                    addLog(`Worker${workerId}: ä¸‹è½½åˆ†æ®µ ${Math.floor(segment.start / 1024 / 1024)}MB-${Math.floor(segment.end / 1024 / 1024)}MB`, 'info');
                    
                    const response = await fetch(videoUrl, {
                        headers: {
                            'Range': `bytes=${segment.start}-${segment.end}`
                        }
                    });
                    
                    if (response.ok) {
                        const duration = Date.now() - startTime;
                        const size = parseInt(response.headers.get('content-length') || '0');
                        const speedKBps = size > 0 ? (size / duration * 1000 / 1024) : 0;
                        
                        // è®°å½•åˆ†æ®µç¼“å­˜ä¿¡æ¯
                        prebufferState.cachedSegments.set(segment.key, {
                            start: segment.start,
                            end: segment.end,
                            size: size,
                            timestamp: Date.now()
                        });
                        
                        // æ›´æ–°ä¸‹è½½ç»Ÿè®¡
                        prebufferState.downloadStats.totalBytes += size;
                        prebufferState.downloadStats.totalTime += duration;
                        prebufferState.downloadStats.recentSpeeds.push(speedKBps);
                        
                        // ä¿æŒæœ€è¿‘10æ¬¡çš„é€Ÿåº¦è®°å½•
                        if (prebufferState.downloadStats.recentSpeeds.length > 10) {
                            prebufferState.downloadStats.recentSpeeds.shift();
                        }
                        
                        addLog(`Worker${workerId}: åˆ†æ®µä¸‹è½½å®Œæˆ ${Math.floor(size / 1024)}KB, é€Ÿåº¦: ${speedKBps.toFixed(1)}KB/s`, 'success');
                        
                        // è¯»å–å“åº”ä½“ä»¥ç¡®ä¿å®Œæ•´ä¸‹è½½
                        await response.arrayBuffer();
                        
                        // æ›´æ–°å¯è§†åŒ–
                        updateBufferVisualization();
                        updateNetworkSpeed();
                    } else {
                        addLog(`Worker${workerId}: åˆ†æ®µä¸‹è½½å¤±è´¥ ${response.status}`, 'warning');
                    }
                } catch (error) {
                    addLog(`Worker${workerId}: åˆ†æ®µä¸‹è½½é”™è¯¯ ${error.message}`, 'warning');
                } finally {
                    prebufferState.downloading.delete(segment.key);
                }
            }
        }

        // æ’­æ”¾è§†é¢‘
        async function playVideo(file) {
            try {
                addLog(`å¼€å§‹æ’­æ”¾: ${file.name}`, 'info');
                
                // ç§»é™¤ä¹‹å‰çš„activeçŠ¶æ€
                document.querySelectorAll('.file-item.active').forEach(item => {
                    item.classList.remove('active');
                });
                
                // æ·»åŠ å½“å‰activeçŠ¶æ€
                event.currentTarget.classList.add('active');
                
                currentVideo = file;
                
                // æ„å»ºè§†é¢‘URL
                let videoPath = file.href;
                if (videoPath.startsWith('/webdav/')) {
                    videoPath = videoPath.substring('/webdav'.length);
                }
                
                const videoUrl = serverUrl + videoPath;
                addLog(`è§†é¢‘URL: ${videoUrl}`, 'info');
                
                // æ›´æ–°ç¼“å†²é…ç½®
                updateBufferConfig();
                
                // è®¾ç½®è§†é¢‘æº
                elements.videoPlayer.src = videoUrl;
                elements.videoStatus.textContent = `åŠ è½½ä¸­: ${file.name}`;
                
                // é‡ç½®è¿›åº¦æ¡å’Œç¼“å†²å¯è§†åŒ–
                elements.progressBar.style.width = '0%';
                elements.progressBuffer.style.width = '0%';
                elements.progressSegments.innerHTML = '';
                elements.bufferStatus.textContent = '0%';
                elements.networkSpeed.textContent = '0 KB/s';
                
                // é‡ç½®é¢„ç¼“å†²çŠ¶æ€
                prebufferState.cachedSegments.clear();
                prebufferState.downloading.clear();
                prebufferState.downloadStats = {
                    totalBytes: 0,
                    totalTime: 0,
                    recentSpeeds: []
                };
                
                // æ¸…é™¤ä¹‹å‰çš„é¢„ç¼“å†²å®šæ—¶å™¨
                if (preloadInterval) {
                    clearInterval(preloadInterval);
                }
                
                // å¦‚æœæ˜¯è‡ªåŠ¨æ¨¡å¼ï¼Œè®¾ç½®é¢„ç¼“å†²å®šæ—¶å™¨
                if (bufferConfig.mode === 'auto') {
                    preloadInterval = setInterval(() => {
                        const duration = elements.videoPlayer.duration;
                        const currentTime = elements.videoPlayer.currentTime;
                        
                        if (duration && currentTime !== undefined) {
                            backgroundPrebuffer(videoUrl, currentTime, duration);
                        }
                    }, 5000); // æ¯5ç§’æ£€æŸ¥ä¸€æ¬¡é¢„ç¼“å†²
                }
                
            } catch (error) {
                addLog(`æ’­æ”¾å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        async function updateStats() {
            try {
                const response = await fetch(serverUrl + '/stats');
                const stats = await response.json();
                
                elements.cacheHits.textContent = stats.hits || 0;
                elements.cacheMisses.textContent = stats.misses || 0;
                elements.hitRate.textContent = stats.hitRate + '%' || '0%';
                elements.cacheSize.textContent = stats.cacheSize || '0 MB';
                
            } catch (error) {
                console.error('è·å–ç»Ÿè®¡å¤±è´¥:', error);
            }
        }

        // å¼€å§‹å®šæœŸæ›´æ–°ç»Ÿè®¡
        function startStatsUpdate() {
            if (statsInterval) clearInterval(statsInterval);
            statsInterval = setInterval(updateStats, 2000);
            updateStats();
        }

        // æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // æ ¼å¼åŒ–æ—¶é—´
        function formatTime(seconds) {
            if (!seconds || isNaN(seconds)) return '00:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // è§†é¢‘äº‹ä»¶ç›‘å¬å™¨
        elements.videoPlayer.addEventListener('loadedmetadata', () => {
            elements.duration.textContent = formatTime(elements.videoPlayer.duration);
            elements.videoStatus.textContent = `å·²å°±ç»ª: ${currentVideo?.name || ''}`;
            addLog('è§†é¢‘å…ƒæ•°æ®å·²åŠ è½½', 'success');
        });

        elements.videoPlayer.addEventListener('timeupdate', () => {
            const current = elements.videoPlayer.currentTime;
            const duration = elements.videoPlayer.duration;
            
            elements.currentTime.textContent = formatTime(current);
            
            if (duration > 0) {
                const progress = (current / duration) * 100;
                elements.progressBar.style.width = progress + '%';
            }
        });

        elements.videoPlayer.addEventListener('progress', () => {
            updateBufferStatus();
        });

        elements.videoPlayer.addEventListener('waiting', () => {
            elements.videoStatus.innerHTML = 'ç¼“å†²ä¸­... <span class="loading"></span>';
            addLog('è§†é¢‘ç¼“å†²ä¸­...', 'warning');
        });

        elements.videoPlayer.addEventListener('playing', () => {
            elements.videoStatus.textContent = `æ’­æ”¾ä¸­: ${currentVideo?.name || ''}`;
            addLog('è§†é¢‘å¼€å§‹æ’­æ”¾', 'success');
        });

        elements.videoPlayer.addEventListener('error', (e) => {
            const error = elements.videoPlayer.error;
            elements.videoStatus.textContent = 'æ’­æ”¾é”™è¯¯';
            addLog(`æ’­æ”¾é”™è¯¯: ${error?.message || 'æœªçŸ¥é”™è¯¯'}`, 'error');
        });

        // è¿›åº¦æ¡ç‚¹å‡»è·³è½¬
        elements.progressContainer.addEventListener('click', (e) => {
            const rect = elements.progressContainer.getBoundingClientRect();
            const percent = (e.clientX - rect.left) / rect.width;
            const duration = elements.videoPlayer.duration;
            
            if (duration > 0) {
                const seekTime = percent * duration;
                elements.videoPlayer.currentTime = seekTime;
                addLog(`è·³è½¬åˆ°: ${formatTime(seekTime)}`, 'info');
            }
        });

        // äº‹ä»¶ç»‘å®š
        elements.connectBtn.addEventListener('click', connectToServer);
        elements.refreshBtn.addEventListener('click', () => {
            if (isConnected) connectToServer();
        });
        
        // é¢„åŠ è½½è®¾ç½®äº‹ä»¶ç›‘å¬
        elements.preloadMode.addEventListener('change', updateBufferConfig);
        elements.bufferSize.addEventListener('change', updateBufferConfig);

        // åˆå§‹åŒ–
        addLog('å¢å¼ºç‰ˆWebDAVæ’­æ”¾å™¨å·²å¯åŠ¨', 'info');
        addLog('æ”¯æŒRangeè¯·æ±‚ã€æ™ºèƒ½ç¼“å­˜ã€å®æ—¶ç›‘æ§', 'info');
    </script>
</body>
</html>